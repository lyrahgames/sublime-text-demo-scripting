import sublime
import sublime_plugin
import os

# This function is responsible for the core task of writing the text to a file.
# It uses an atomic write pattern to prevent file corruption.
def send(domain, msg):
  """
  Atomically writes a message to a file derived from the domain path.

  Args:
    domain (str): The full path of the source file.
    msg (str): The string content to write to the file.
  """

  # Safely write the message to a temporary file.
  # The 'w' mode will create or overwrite the file.
  addr = domain + '.fdm'
  tmp = addr + '.send'
  with open(tmp,'w', encoding='utf-8') as file:
    file.write(msg)
  # Atomically rename the temporary file to the final target file.
  # This operation ensures that the .fdm file is not left half-written.
  os.rename(tmp, addr)

# This class acts as a template for all other commands in this plugin.
# It handles the common logic of getting the file path and calling the send function.
class demo_scripting_base_command(sublime_plugin.TextCommand):
  """
  A base command that handles the boilerplate of getting the filename
  and sending the text generated by a subclass.
  """
  def run(self, edit):
    # Get the full path of the currently active file if available.
    domain = self.view.file_name()
    if not domain:
      return
    # Call the 'text_to_run' method, which must be implemented by the subclass.
    # Then, pass the resulting text to the send function.
    send(domain, self.text_to_run())

# This command sends the entire content of the file.
class demo_scripting_run_all_command(demo_scripting_base_command):
  """Sends the entire content of the current view."""
  def text_to_run(self):
    return self.view.substr(sublime.Region(0, self.view.size()))

# This command sends the selected text or the current line(s).
class demo_scripting_run_line_command(demo_scripting_base_command):
  """
  Sends specific text based on the user's cursors. For each cursor,
  if text is selected, it sends that selection. If not, it sends the whole line.
  """
  def text_to_run(self):
    selection = ""
    for region in self.view.sel():
      if region.empty():
        selection += self.view.substr(self.view.line(region)) + '\n'
      else:
        selection += self.view.substr(region) + '\n'
    return selection

# This command sends a logical block of Lua code.
class demo_scripting_run_lua_block_command(demo_scripting_base_command):
  """Sends a logical block of code based on indentation and blank lines."""

  def text_indent(self, text):
    """Calculates the visual indentation of a string, respecting tab settings."""
    if not text.strip():
      return -1
    indent = 0
    for c in text:
      if c == ' ':
        indent += 1
      elif c == '\t':
        indent += self.view.settings().get('tab_size', 4)
      else:
        break
    return indent

  def line_indent(self, line):
    """Helper to get the indentation of a specific line number."""
    region = self.view.line(self.view.text_point(line, 0))
    return self.text_indent(self.view.substr(region))

  def block_boundary(self, lines):
    """
    A custom function to find a boundary. It searches through the given lines,
    waits to find a line with zero indentation,
    and then returns it if the following line is a blank line.
    """
    line = 0
    check = False
    for i in lines:
      indent = self.line_indent(i)
      if indent == 0:
        line = i
        check = True
      elif indent == -1:
        if check:
          return line
      else:
        check = False
    return i

  def block_text(self, point):
    """
    Calculates the full block of text surrounding a given point (cursor).
    """

    # Get the line number of the cursor and the total number of lines in the file.
    line, _ = self.view.rowcol(point.begin())
    line_count = self.view.rowcol(self.view.size())[0] + 1

    # Backward and forward search to find start and end of block.
    n1 = self.block_boundary(range(line, -1, -1))
    n2 = self.block_boundary(range(line, line_count))

    # Convert line numbers to region and extract the text of it.
    first = self.view.text_point(n1, 0)
    last = self.view.text_point(n2 + 1, 0)
    return self.view.substr(sublime.Region(first, last))

  def text_to_run(self):
    text = ""
    for region in self.view.sel():
      if region.empty():
        text += self.block_text(region)
      else:
        text += self.view.substr(region) + '\n'
    return text
